일부칼럼은   프로젝션 기능
조인	여러개의 데이터 테이블, n개이상의 테이블에서 검색

*은 all이라는 뜻


comlumn department_name format a17

a17 알파벳자리수 말함

comlumn department_name clear


employees 테이블 모든 ㄷ데이터

컴파일 3단계로 (검증, 실행계획, 

SQL*Plus: Release 11.2.0.2.0 Production on 화 11월 17 10:01:21 2020

Copyright (c) 1982, 2014, Oracle.  All rights reserved.

SQL> conn system/12345
Connected.
SQL> alter user hr
  2  identified by hr;

User altered.

SQL> alter user hr
  2  account unlock;

User altered.

SQL> conn hr/hr
Connected.
SQL>

숫자는 오른쪽     문자열는 왼쪽
칼럼 헤딩들은 항상 대문자로 출력

날짜는 +-가능  */불가능

nvl 함null값 대체   null value language


SELECT last_name, salary*12*nvl(commission_pct,1)  from employees;

allias 는 공백보단 as 써주는게 성능적으로 좋음
"" 쓰면 대소문자 섞임  즉 대문자로 안바뀜  그리고 복수 문장 쓰고 싶을때

as와 "" 굳이 2개 붙여서 쓸 필요 없음
select last_name || job_id AS "Employees" FROM employees;

리터럴 문자열 (기억하면 좋음?)

그중에서 문자열과 날자는 ''  싱글퍼테이션 반드시 찍어줘야함

disctinct      중복제거      멀티플 중복제거도 가능

2장 where절

where 절이 select절 보다 먼저 실행되서  행이 제한된다고 보면 된다.

연산자   <> 보다 !=가 더 빠름 성능적 측면
where절에 있는 칼럼들은 셀렉문안에 넣어주는게 좋다

between 은 date와 string 에도 모두가능하나 의미는 없다 

d1118

IN 연산자 = 복수연산자
LIKE 연산자    %는 문장전체의미, _는 문자 하나를 의미함
LKIKE 'S%'; 는 S가 들어가는 문장 전체
%s% 는 s로시작하거나 끝나는 것

null 연산자 >>  IS NULL;

작년 정보처리 실기에 LIKE 나왔음
조건이 여러개라면?  AND OR NOT 연산자
칼럼 앞에 NOT 쓸수 잇음
WHERE not department_id=90;

ORDER BY 절 (정렬) 오름 VS 내림  ascending  descending  오름차순이 기본값
ORDER BY NUMBER (이건 버그 같은 것  칼럼 숫자 말함 3넣으면 3번째 칼럼 정렬됨)
ORDER BY 는 맨 마지막 줄이라 그 뒤에는 다른 명령어 불가
널값 오름차순에선 마지막에   내림차순에는 처음에 (즉 값이 높다는 뜻?)

ORDER BY 는 WHERE절과 다르게 ALLIAS 써도 알아먹음.


SELECT last_name, salary*12 ANNSAL
FROM employees
ORDER BY department_id, salary*12 DESC

// 멀티플 정렬이 됨  부서별로 되버림

실습문제

SELECT last_name
FROM employees
WHERE last_name like '%a%'  and last_name like  '%e%'
/
만약  %a%e% 로 하면 무조건  a e만 찾음    e a 는 못찾음

d1119

조인하려면
where 절에  n-1에 해당하는 조건을 반드시 적어줘야함

오라클 전용조인만 살펴봄(어차피 명령어만 다름)

등가조인 : 데이터가 같을떄
비등가 : 같은 데터 없을때
아우터조인 : 어느 한쪽 데이터가 많을때
포괄조인 : 등가조인의 확장형
셀프조인 : 테이블 하나 (어렵다)

from join에서도 allias 쓸 수 있다?

select e.last_name, d.department_name, e.department_id
from employees  e, departments  d
where employees.department_id=departments.department_id
/

//혼용은 불가  from selec 둘다 allias 써라

join 쓸 때  추가조건은 and써라  or쓰지마

아우터조인
select e.last_name, d.department_name, e.department_id
from employees e, departments d
where e.department_id = d.department_id(+)
/

//부족한쪽에 + 쓰면

비등가조인 where e.salary between j.lowest_sal and j.highest_sal;
대부분 between 씀   
비등가조인은 자주쓰진 않음


select e.last_name, d.department_name, d.location_id, l.city
from employees e, departments d, locations l
where  e.department_id = d.department_id
and d.location_id = l.location_id
and e.commission_pct is not null
/











//성능 측면 고려하면 조인을 먼저 쓰는 게 좋다. 

근무사원번호, 이름, 관리자번호, 관리자이름 출력
//자체참조

select e.employee_id, e.last_name, e.manager_id, m.last_name
from employees e, employees m
where e.manager_id = m.employee_id
/

그룹함수 oracle은 7개
sum 과 avg는 숫자데이터만 가능 
max min 은 모든 데이터타입 가능
그룹함수들은 null을 무시함  (즉 커미션 34명 받으면 34로나눔  전체사원으로 안나눔

널값 고려하려면 nvl써라
select avg(nvl(commission_pct,0)), sum(commission_pct)/107
from employees
/



select count(distinct department_id)
from employees
/

그룹함수는 all과 distinct 옵션 두개 사용가능  기본적으로 all이 default임

d1120    250페이지
select e.last_name, e.hire_date
from employees e, employees m
where e.manger_id = m.employee_id
//////////////모르겠음


hire_date가 더 빠른얘들 찾아라


select department_id, avg(salary)
from employees;  
//오류남  그룹화시켜줘야함
>>department_id 그룹화 시켜줘야함

group by 절에 그룹화 안되는 그룹 꼭 명시 꼭해줘야 즉
>>select department_id, avg(salary)
from employees
group by department_id
/
// 셀렉절에 deparrtmen_id 안써줘도 되나 그러면 보기 불편함



select department_id, job_id, avg(salary)
from employees
group by department_id, job_id
order by department_id
/

//department_id별로 그룹화 > 업무별 > 즉 그룹화가 2번 일어남
셀렉트절에 있는 순서대로 그룹화가 시작됨


select department_id, AVG(salary)
from employees
WHERE AVG(salary) >8000
group by department_id, job_id
/
//오류남 where절이 먼저 실행되서 그룹제한이 안댐 즉 where이 아닌 
having 으로 조건설정해줘야함

having은 group에 대한 조건을 주는 것(where과 달리 나중에 실행됨 즉 avg 쓸수있음)
where절은 행을 제한, having은 그룹을 제한하는 절
having절과 group by절은 순서상관없음
having sav(salary) >800 and     이거 쓰지마 (처리속도 느림)


select department_id, MAX(salary)
from employees
group by department_id
having MAX(salary)>10000
order by department_id
/

// department 별 10000만 넘는 급여 중 최대값들 구함 

select job_id, SUM(salary) PAYROLL
FROM employees
where job_id not like '%REP%'
GROUP BY job_id
HAVING SUM(salary) > 13000
ORDER BY SUM(salary)
/

// from 절 > where절> group by절> selec절 > having절> order by절 순서로 처리

select emp.last_name, emp.employee_id, emp.hire_date
from employees emp, employees mgr
where emp.manager_id



회사 전체 쵀대 급여, 최소급여, 급여 총 합 및 평균 급여를 출력하시오
select MAX(salary), MIN(salary), SUM(salary), AVG(salary)
from employees
/


직업별 최대급여  최소급여 급여 총 합 및 평균 급여를 출력하시오
단 최대 급여는 맥스, 최소급여는 nin, 급여 총합은 sum및 평균급여는 avg로 출력하고 직업을 오름차순으로 정렬하시오

select job_id, MAX(salary) MAX,MIN(salary) MIN, SUM(salary) SUM, AVG(salary) AVG
from employees
group by job_id
order by job_id
/


20번 문제   동일한 직업 가진 사원들의 총 수 

select job_id, COUNT(employee_id)
from employees
group by job_id
order by job_id
/

21번 매니저 근무하는 사원 총 수 

22. 사내의 최대 급여 및 최소 급여의 차이
select MAX(salary)-MIN(salary)

23번  매니저의 사번 및 그 매니저 및 사원들 중 최소급여를 받는 사원의 급여를 출력하시오
매니저가 없는 사람들은 제외한다
최소 급여가 5000미만인 경우도 제외한다
급여기준 역순으로 조회한다.

select manager_id, min(salary)
from employees
where manager_id is not null
group by manager_id
having min(salary) >= 5000
order by min(salary) desc
/


  1  select manager_id, min(salary)
  2  from employees
  3  where salary>5000
  4  group by manager_id
  5* having manager_id is not null
SQL> /

// 내가 낸 오답  위임

24번 부서명 부서위치id 각부서별 사원 총수 , 각 부서별 평균 그병를 출력하되 부서위치를 오름차순으로

select d.location_id,  count(e.department_id), AVG(e.salary), d.department_name
from employees e, departments d
where e.department_id = d.department_id
group by   d.department_name, d.location_id
order by d.location_id
/

>> order by 는   그룹함수 안쓴 모든 셀렉문을 써줘야함


Q 아벨이라는 사원 급여보다 더 많은 급여를 받는 사원의 이름과 급여를 출력하시오
(아벨 급여 검색 없이 한번에 처리하는 법) >> 서브쿼리

select last_name, salary
from employees
where salary >(select salary
		from employees 
		where last_name = 'Abel')
/


서브쿼리는 먼저 실행됨  서브쿼리 실행 후 값을 메인쿼리로 넘겨줌 

select   from  where having   등 거의 모든 문장에서 사용가능?
where 과 having  부터 서브쿼리 배워보자

where과 havaing 서브쿼리 안에 order by 쓸 필요 업다

정렬은 메모리에서 처리함  즉 메모리 두번 차지함 게다가 할때마다 메모리 잡아먹음

from 절에서 사용되는 order by 는 굉장히 중요함

중요- 단일 행 서브 쿼리에는 단일 행 연산자를 사용합니다. 다중행 서브쿼리에는 다중 행 연산자를 사용합니다.


select last_name, job_id
from employees
where job_id = (select job_id
			from employees
			where employee_id = 141)
/
